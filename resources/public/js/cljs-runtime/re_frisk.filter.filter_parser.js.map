{"version":3,"sources":["re_frisk/filter/filter_parser.cljs"],"mappings":"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","names":["re-frisk.filter.filter-parser/read-all","rdr","G__65071","cljs.core._EQ_","cljs.tools.reader.reader-types/peek-char","cljs.core/cons","cljs.tools.reader.reader-types/read-char","re-frisk.filter.filter-parser/read-string'","s","sr","cljs.tools.reader.reader_types.string_push_back_reader","val","cljs.tools.reader.read","rest","clojure.string.join","re-frisk.filter.filter-parser/parse-freeform","vec__65083","cljs.core.nth","prefix","clojure.string.split","or__4126__auto__","re-frisk.filter.filter-parser/parse-clojure-expr","e65092","map__65093","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","cljs.core.get","foo","_","re-frisk.filter.filter-parser/parse-clojure-string","e65099","map__65107","vec__65100","clojure.string/replace","re-frisk.filter.filter-parser/parse-part","G__65114","cljs.core/first","re-frisk.filter.filter-parser/parse'","clojure.string/trim","map__65120","re-frisk.filter.filter-parser/parse","cljs.core.into"],"sourcesContent":["(ns re-frisk.filter.filter-parser\n  (:require [cljs.tools.reader.reader-types\n             :refer [string-push-back-reader peek-char read-char]]\n            [cljs.tools.reader :as reader]\n            [clojure.string :as str]))\n\n(defn- read-all [rdr]\n  (case (peek-char rdr)\n    nil '()\n    (cons (read-char rdr) (read-all rdr))))\n\n;; like reader/read-string, but returns unread portion of the string too\n(defn- read-string' [s]\n  (let [sr (string-push-back-reader s)\n        val (reader/read sr)\n        rest (str/join (read-all sr))]\n    {:val val :rest rest}))\n\n(defn- parse-freeform [s]\n  (let [[prefix rest] (str/split s #\"\\s+\" 2)]\n    {:val {:free prefix} :rest (or rest \"\")}))\n\n(defn- parse-clojure-expr [s]\n  (try\n    (let [{:keys [val rest] :as foo} (read-string' s)]\n      {:val {:expr val} :rest rest})\n    (catch :default _ (parse-freeform s))))\n\n(defn- parse-clojure-string [s]\n  (try\n    (let [{val :val rest :rest} (read-string' s)]\n      {:val {:expr val} :rest rest})\n    (catch :default _\n      ;; If a string cannot be fully parsed, mark it as \"unfinished\"\n      ;; to do the prefix match later: \"abc will match \"abc\" and \"abcde\"\n      (let [[prefix rest] (str/split s #\"\\s+\" 2)\n            prefix (str/replace prefix #\"^\\\"\" \"\")] ; Kill \" at the beginning\n        {:val {:string-prefix prefix} :rest (or rest \"\")}))))\n\n(defn- parse-part [s]\n  (case (first s)\n    ;; If it looks like a Clojure literal, parse it as such\n    (\"[\" \"(\" \"{\" \"#\" \"\\\\\" \"'\" \":\") (parse-clojure-expr s)\n    ;; If it looks like a string, parse it as a string (relaxed)\n    \"\\\"\" (parse-clojure-string s)\n    ;; Otherwise it's a freeform\n    (parse-freeform s)))\n\n(defn- parse' [s]\n  (let [s (str/trim s)\n        ;; Remove outer [] of the expression, if any\n        s (str/replace s #\"^\\[(.*)\\]$\" \"$1\")]\n    (if (= s \"\") '()\n        (let [{val :val rest :rest} (parse-part s)]\n          (cons val (parse' rest))))))\n\n(defn parse [s]\n  (into [] (parse' s)))\n"]}