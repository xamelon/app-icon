{"version":3,"sources":["re_frisk/utils.cljs"],"mappings":";AAKA,AAAA,AAAMA,AAAUC,AAAMC,AAAaC;AAAnC,AACE,AAAI,AAAAC,AAAKF;AAAL,AAAA,AAAAE;AAAkB,AAACC,AAAKJ;;AAAxBG;;;AACF,AAAA,AACE,AAACG,AAAK,AAACC,AAAYP;AADrB,AAAAK,AAEkBG;AAFlB,AAGI,AACE,AAAA,AAACC,AAAOP;;AACRF;;AACNA;;;AAEJ,AAAA,AAAMU,AAAgBV,AAAMC,AAAaU;AAAzC,AACE,AAAKC;AAAL,AACE,AAACH,AAAOR,AAAaW;;AACrB,AAAA,AAACC,AAAMb,AAAMc,AAAMH;;AACnB,AAAA,AAACI;AAAD,AAAgB,AAACF,AAAMb,AAAMgB,AAAOL;AAApC;;;AAEJ,AAAA,AAAMM,AAAcC;AAApB,AACE,AAAKC;AAAL,AACE,AAAAC,AAAI,AAAA,AAASD;AAAb,AAAA,AAAAC;AAAAA;;AACI,AAAMC,AAAK,AAACC,AAAkB,AAACC,AAAK,AAACC,AAAM,AAAA,AAAQL;AAC7CD,AAAK,AAACI,AAAkBJ;AAD9B,AAEE,AAAA,AAACO,AAAK,AAACC,AAAgBL,AAAKH;;;;AAEtC,AAAA,AAAMS,AAAeC;AAArB,AACE,AAAMC,AAAU,AAAA,AAACC,AAAa,AAAA,AAAA,AAACC,AAAeH;AAA9C,AACE,AAAI,AAAA,AAAG,AAACI,AAAMH;AACZ,AAAA,AAAA,AAAS,AAAA,AAACI,AAAgB,AAACC,AAAKV,AAAM,AAAA,AAACM,AAAa,AAACN,AAAMK,AAClD,AAACM,AAAKN;;AACfD;;;AAEN,AAAA,AAAMQ,AAAqBC;AAA3B,AACE,AAAMA;AAAN,AACE,AAAM,AAAA,AAAGA;AAAT;;AAAA,AACM,AAAGA,AAAE,AAAA,AAAGC;AAA0B,AAAA,AAAGA;;AAD3C,AAEYD;;;;;AAHd;;;AAKF,AAAA,AAAME,AAASC;AAAf,AACE,AAACC,AAAED,AAAK,AAAA,AAAGF;;AAEb,AAAA,AAAMI,AAAQ1C;AAAd,AACE,AAAA,AAAK,AAAA,AAAC2C,AAAsB3C;;AAE9B,AAAA,AACA,AAAA,AAAA4C,AAAAC,AAAAC;AAAA;AAAA,AAAA,AAASC,AAAW,AAAA,AAACC;;AAErB,AAAA,AAAMC,AAAgBC,AAAQC;AAA9B,AACE,AAAA,AAAAC,AAAKL;AACH,AAAA,AAACtC,AAAOsC;;AACR,AACE,AAAA,AAACtC,AAAOsC;;AACR,AAAChC,AAAcsC,AAAaF,AAAKD,AAAQC;;AACzC,AAACD,AAAAA,AAAAA;;;AAEP,AAAA,AAAOG,AAAcH,AAAQC;AAA7B,AACE,AAAA,AAAAC,AAAME,AAAOP;AAAb,AACE,AAAA,AAACtC,AAAOsC;;AACR,AAAM,AAAA,AAACN,AAAEa;AAAT,AACE,AAACL,AAAeC,AAAQC;;AAD1B","names":["re-frisk.utils/sort-map","value","checkbox-val","checkbox","and__4115__auto__","cljs.core/map?","e65526","cljs.core.into","cljs.core/sorted-map","e","cljs.core/reset!","re-frisk.utils/on-change-sort","key","val","cljs.core.swap_BANG_","cljs.core/assoc","js/setTimeout","cljs.core/dissoc","re-frisk.utils/filter-event","text","item","or__4126__auto__","name","clojure.string/lower-case","cljs.core/name","cljs.core/first","cljs.core.not_EQ_","clojure.string.index_of","re-frisk.utils/truncate-name","event","namespace","clojure.string.split","clojure.string/replace","cljs.core/count","clojure.string.join","cljs.core.mapv","cljs.core/last","re-frisk.utils/normalize-draggable","x","js/window.innerWidth","re-frisk.utils/closed?","left","cljs.core._EQ_","re-frisk.utils/str-ms","goog.string/format","js/re-frisk","js/re-frisk.utils","js/re-frisk.utils.call-state","re-frisk.utils/call-state","cljs.core.atom","re-frisk.utils/call-and-chill","handler","time","cljs.core/deref","re-frisk.utils/call-timeout","state"],"sourcesContent":["(ns re-frisk.utils\n  (:require [clojure.string :as string]\n            [goog.string :as gstring]\n            [goog.string.format]))\n\n(defn sort-map [value checkbox-val checkbox]\n  (if (and checkbox-val (map? value))\n    (try\n      (into (sorted-map) value)\n      (catch :default e\n        (do\n          (reset! checkbox false)\n          value)))\n    value))\n\n(defn on-change-sort [value checkbox-val key]\n  (fn [val]\n    (reset! checkbox-val val)\n    (swap! value assoc key true)\n    (js/setTimeout #(swap! value dissoc key) 100)))\n\n(defn filter-event [text]\n  (fn [item]\n    (or (:trace? item)\n        (let [name (string/lower-case (name (first (:event item))))\n              text (string/lower-case text)]\n          (not= (string/index-of name text) nil)))))\n\n(defn truncate-name [event]\n  (let [namespace (string/split (string/replace event #\":\" \"\") #\"/\")]\n    (if (> (count namespace) 1)\n      (str \":\" (string/join \".\" (mapv first (string/split (first namespace) #\"\\.\")))\n           \"/\" (last namespace))\n      event)))\n\n(defn normalize-draggable [x]\n  (when x\n    (cond (< x 80) 80\n          (> x (- js/window.innerWidth 30)) (- js/window.innerWidth 30)\n          :else x)))\n\n(defn closed? [left]\n  (= left (- js/window.innerWidth 30)))\n\n(defn str-ms [value]\n  (str (gstring/format \"%.2f\" value) \" ms\"))\n\n(declare call-timeout)\n(defonce call-state (atom nil))\n\n(defn call-and-chill [handler time]\n  (if @call-state\n    (reset! call-state :call)\n    (do\n      (reset! call-state :chill)\n      (js/setTimeout call-timeout time handler time)\n      (handler))))\n\n(defn- call-timeout [handler time]\n  (let [state @call-state]\n    (reset! call-state nil)\n    (when (= state :call)\n      (call-and-chill handler time))))"]}